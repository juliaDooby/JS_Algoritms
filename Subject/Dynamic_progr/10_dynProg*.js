---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
Динамическое программирование (ДП) — это метод решения задач, которые можно разделить на подзадачи, решения которых могут быть использованы для решения исходной задачи. В этом подходе важно запоминать уже решенные подзадачи, чтобы избежать повторных вычислений.
1. ⌛ Задача: Задача о рюкзаке (0/1)
Условие:
Дано множество предметов, каждый из которых имеет вес и стоимость. Нужно выбрать предметы таким образом, чтобы их суммарная стоимость была максимальной, а общий вес не превышал заданной вместимости рюкзака.
🎯 Решение:
```javascript
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }

  return dp[n][capacity];
}

const weights = [2, 3, 4, 5];
const values = [3, 4, 5, 6];
const capacity = 5;
console.log(knapsack(weights, values, capacity));  // 7
```
Объяснение:
Используется двумерный массив `dp`, где `dp[i][w]` — это максимальная стоимость, которую можно получить с первым `i` предметом и рюкзаком вместимости `w`. Мы итеративно заполняем этот массив, выбирая либо не включать предмет в рюкзак, либо включить его.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
2. ⌛ Задача: Поиск длины наибольшей общей подпоследовательности (LCS)
Условие:
Даны две строки. Нужно найти длину наибольшей общей подпоследовательности (LCS).
🎯 Решение:
```javascript
function lcs(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[m][n];
}

const str1 = "AGGTAB";
const str2 = "GXTXAYB";
console.log(lcs(str1, str2));  // 4
```
Объяснение:
Мы создаем двумерный массив `dp`, где `dp[i][j]` хранит длину LCS для первых `i` символов первой строки и первых `j` символов второй строки. Если символы строк совпадают, увеличиваем значение на 1, иначе берем максимальное значение из соседних ячеек.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
3. ⌛ Задача: Задача о числе способов разложения числа (Проблема разбиения)
Условие:
Найти количество способов разложить число `n` на сумму чисел, используя числа от 1 до `n`.
🎯 Решение:
```javascript
function countPartitions(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;  // Есть один способ разложить 0 (пустое разбиение)

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

const n = 5;
console.log(countPartitions(n));  // 7
```
Объяснение:
Используем динамическое программирование для подсчета способов разложения числа. Мы начинаем с разбиения 0 и добавляем все возможные числа от 1 до `n`.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
4. ⌛ Задача: Числа Фибоначчи
Условие:
Найти `n`-е число Фибоначчи.
🎯 Решение:
```javascript
function fibonacci(n) {
  const dp = Array(n + 1).fill(0);
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(fibonacci(10));  // 55
```
Объяснение:
Числа Фибоначчи можно вычислить, используя предыдущие два числа, что и делает этот алгоритм. Мы создаем массив для хранения всех чисел до `n`, начиная с 0 и 1.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
5. ⌛ Задача: Задача о минимальной стоимости пути в сетке
Условие:
Дана сетка (матрица), где каждая ячейка содержит стоимость перемещения через нее. Нужно найти минимальную стоимость пути от верхнего левого угла до правого нижнего, перемещаясь только вниз или вправо.
🎯 Решение:
```javascript
function minPathSum(grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = Array(m).fill().map(() => Array(n).fill(0));

  dp[0][0] = grid[0][0];

  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }

  return dp[m - 1][n - 1];
}

const grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
];
console.log(minPathSum(grid));  // 7
```
Объяснение:
Для каждой ячейки мы находим минимальную стоимость пути, добавляя стоимость текущей ячейки к минимальной стоимости из соседей (слева или сверху).
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
6. ⌛ Задача: Задача о лестнице
Условие:
Нужно найти количество способов подняться на вершину лестницы, если можно делать шаги по 1 или 2 ступеньки.
🎯 Решение:
```javascript
function climbStairs(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(climbStairs(5));  // 8
```
Объяснение:
Для каждой ступеньки мы находим количество способов, используя предыдущие две ступеньки (по аналогии с числами Фибоначчи).
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
7. ⌛ Задача: Декартовы произведения (Перестановки с повторениями)
Условие:
Найти все перестановки элементов множества с возможными повторениями.
🎯 Решение:
```javascript
function permute(nums) {
  const res = [];
  const dp = (current) => {
    if (current.length === nums.length) {
      res.push([...current]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      current.push(nums[i]);
      dp(current);
      current.pop();
    }
  };
  dp([]);
  return res;
}

console.log(permute([1, 2, 3]));
```
Объяснение:
Используем рекурсивный подход для генерации всех возможных перестановок с помощью динамического программирования.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
8. ⌛ Задача: Разбиение числа на сумму чисел
Условие:
Найти количество способов разложить число `n` на сумму чисел от 1 до `n`.
🎯 Решение:
```javascript
function partitionNumber(n) {
  const dp = Array(n + 1).fill(0);
  dp[0] = 1;

  for (let i = 1; i <= n; i++) {
    for (let j = i; j <= n; j++) {
      dp[j] += dp[j - i];
    }
  }

  return dp[n];
}

console.log(partitionNumber(5));  // 7
```
Объяснение:
Задача заключается в том, чтобы найти количество разбиений числа `n`. Для этого создаем массив `dp`, где `dp[i]` хранит количество способов разбиения числа `i`. Внешний цикл пробегает по числам от 1 до `n`, а внутренний — по возможным значениям для разбиений.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
9. ⌛ Задача: Наибольшая возрастающая подпоследовательность
Дана последовательность чисел. Необходимо найти длину наибольшей возрастающей подпоследовательности.
🎯 Решение:
```javascript
function longestIncreasingSubsequence(nums) {
  if (nums.length === 0) return 0;

  const dp = Array(nums.length).fill(1);

  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return Math.max(...dp);
}

console.log(longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]));  // 4
```
Объяснение:
Мы используем динамическое программирование для решения задачи. В массиве `dp` хранится длина наибольшей возрастающей подпоследовательности, заканчивающейся на каждом элементе. Если элемент текущей последовательности больше предыдущего, то длина возрастающей подпоследовательности обновляется.
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
⋙ ❍ Динамическое программирование:
---
10. ⌛ Задача: Минимальная сумма пути в треугольнике
Условие:
Дан треугольник чисел, нужно найти путь с минимальной суммой, начиная с вершины и двигаясь к нижнему ряду, только перемещаясь по соседним числам.
🎯 Решение:
```javascript
function minimumTotal(triangle) {
  const n = triangle.length;
  const dp = Array(n).fill(0);

  // Идем с последнего ряда треугольника
  for (let row = n - 1; row >= 0; row--) {
    for (let col = 0; col <= row; col++) {
      if (row === n - 1) {
        dp[col] = triangle[row][col];
      } else {
        dp[col] = Math.min(dp[col], dp[col + 1]) + triangle[row][col];
      }
    }
  }

  return dp[0];
}

const triangle = [
  [2],
  [3, 4],
  [6, 5, 7],
  [4, 1, 8, 3]
];

console.log(minimumTotal(triangle));  // 11
```
Объяснение:
Мы начинаем с последнего ряда треугольника и двигаемся к первому. Для каждой ячейки вычисляем минимальную сумму, добавляя минимальную сумму из соседних элементов на следующем уровне. Таким образом, получаем минимальную сумму пути, начиная с вершины треугольника.
Эти задачи показывают разнообразие применения динамического программирования и решают различные задачи с использованием подхода оптимизации и запоминания подзадач.
---------------------------------------------------------------------------------------------
