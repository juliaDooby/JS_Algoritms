---------------------------------------------------------------------------------------------
ðŸ“Œ [Ð–Ð°Ð´Ð½Ñ‹Ðµ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ñ‹]:
---
4. Ð—Ð°Ð´Ð°Ñ‡Ð°: Ð–Ð°Ð´Ð½Ñ‹Ð¹ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð´Ð»Ñ Ð½Ð°Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¿ÑƒÑ‚Ð¸ Ð² Ð³Ñ€Ð°Ñ„Ðµ (ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð”ÐµÐ¹ÐºÑÑ‚Ñ€Ñ‹)
âŒ› Ð—Ð°Ð´Ð°Ñ‡Ð°: ÐÐ°Ð¹Ñ‚Ð¸ ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ Ð¾Ñ‚ Ð¸ÑÑ…Ð¾Ð´Ð½Ð¾Ð¹ Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ Ð´Ð¾ Ð²ÑÐµÑ… Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ð²ÐµÑ€ÑˆÐ¸Ð½ Ð² Ð³Ñ€Ð°Ñ„Ðµ Ñ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼Ð¸ Ð²ÐµÑÐ°Ð¼Ð¸.
ðŸŽ¯ Ð ÐµÑˆÐµÐ½Ð¸Ðµ:
```javascript
function dijkstra(graph, start) {
    const dist = {};
    const visited = new Set();
    const queue = [[start, 0]];

    graph.forEach((_, vertex) => {
        dist[vertex] = Infinity;
    });
    dist[start] = 0;

    while (queue.length > 0) {
        const [vertex, distance] = queue.pop();
        if (visited.has(vertex)) continue;
        visited.add(vertex);

        for (let [neighbor, weight] of graph[vertex]) {
            const newDist = distance + weight;
            if (newDist < dist[neighbor]) {
                dist[neighbor] = newDist;
                queue.push([neighbor, newDist]);
            }
        }
    }

    return dist;
}

const graph = {
    A: [['B', 1], ['C', 4]],
    B: [['A', 1], ['C', 2], ['D', 5]],
    C: [['A', 4], ['B', 2], ['D', 1]],
    D: [['B', 5], ['C', 1]],
};
console.log(dijkstra(graph, 'A')); // Ð’Ñ‹Ð²Ð¾Ð´Ð¸Ñ‚ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ€Ð°ÑÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¾Ñ‚ Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ A
```
ÐžÐ±ÑŠÑÑÐ½ÐµÐ½Ð¸Ðµ: ÐœÑ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð¶Ð°Ð´Ð½Ñ‹Ð¹ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð”ÐµÐ¹ÐºÑÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð½Ð°Ñ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ñ… Ð¿ÑƒÑ‚ÐµÐ¹ Ð² Ð³Ñ€Ð°Ñ„Ðµ Ñ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼Ð¸ Ð²ÐµÑÐ°Ð¼Ð¸.
--------------------------------------------------------------------------------------------- 
