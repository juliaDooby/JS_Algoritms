---------------------------------------------------------------------------------------------
⋙ ❍ Графы:
---
9. Нахождение мостов (DFS)
```js
// Используем алгоритм Тарьяна
```
Описание:  
В неориентированном графе мост — это ребро, удаление которого увеличивает количество компонент связности.  
Требуется найти все такие мосты.
  ---
Ввод:
- `n` — количество вершин (нумерация с `0` до `n-1`).
- `edges` — список рёбер в формате `[u, v]`, где `u` и `v` — связанные вершины.
Требуется:  
Вернуть массив всех мостов в графе.
---
Решение через DFS (Алгоритм Тарьяна)
Идея:
- `tin[v]` — время входа в вершину `v` в процессе DFS.
- `low[v]` — минимальное время достижения вершины через обратные ребра (или себя).
- Если у вершины `to` выполнено `low[to] > tin[v]`, значит ребро `(v, to)` — мост.
---
Реализация на JavaScript
```javascript
function findBridges(n, edges) {
  const graph = Array.from({ length: n }, () => []);
  for (const [u, v] of edges) {
    graph[u].push(v);
    graph[v].push(u);
  }

  const tin = Array(n).fill(-1);
  const low = Array(n).fill(-1);
  const visited = Array(n).fill(false);
  const bridges = [];
  let timer = 0;

  function dfs(v, parent = -1) {
    visited[v] = true;
    tin[v] = low[v] = timer++;
    
    for (const to of graph[v]) {
      if (to === parent) continue; // Не возвращаемся к родителю
      
      if (visited[to]) {
        // Обратное ребро
        low[v] = Math.min(low[v], tin[to]);
      } else {
        // Деревянное ребро
        dfs(to, v);
        low[v] = Math.min(low[v], low[to]);
        
        if (low[to] > tin[v]) {
          bridges.push([v, to]);
        }
      }
    }
  }

  for (let i = 0; i < n; i++) {
    if (!visited[i]) {
      dfs(i);
    }
  }

  return bridges;
}

// Пример:
const n = 5;
const edges = [
  [0, 1],
  [1, 2],
  [2, 0],
  [1, 3],
  [3, 4]
];

console.log(findBridges(n, edges));
// Вывод: [ [ 3, 4 ], [ 1, 3 ] ]
```
Пояснение:
1. Мы строим обычный список смежности для графа.
2. Начинаем DFS:
   - Помечаем `tin[v]` — момент входа в вершину.
   - `low[v]` сначала равен `tin[v]`.
   - При обходе соседей:
     - Если сосед посещён, обновляем `low[v]` через `tin[to]`.
     - Иначе вызываем `dfs` для соседа и обновляем `low[v]` через `low[to]`.
3. Условие моста:
   - Если `low[to] > tin[v]`, то `(v, to)` — мост.
- Если после обхода поддерева вершины `to` мы не смогли попасть в вершину `v` или её предков, значит удаление ребра `(v, to)` разрывает граф.
- Поэтому ребро — критически важное для связности.
---------------------------------------------------------------------------------------------
